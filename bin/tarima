#!/bin/sh
':' // ; exec "$(command -v nodejs || command -v node)" "$0" "$@"
;

'use strict';

/* eslint-disable global-require */
/* eslint-disable no-nested-ternary */

const path = require('path');
const wargs = require('wargs');

// common helpers
const die = process.exit.bind(process);

const $ = require('./lib/utils');

// safe
let logger;

function errLog(message) {
  if (logger) {
    logger.printf('\r\r{%error|%s%}\n', message);
  } else {
    process.stderr.write(`\r${message}\n`);
  }
}

const DEFAULTS = {
  bundler: 'rollup',
  bundle: '**/index.js',
  public: 'public',
  dest: 'build',
  config: 'config',
  reloader: 'index.js',
  env: process.env.NODE_ENV || 'development',
  port: process.env.PORT || 3000,
  proxy: 'localhost:8080',
};

let _;

try {
  _ = wargs(process.argv.slice(2), {
    arrays: 'SxlLwyREG',
    booleans: 'qvVOdfsh',
    defaults: DEFAULTS,
    aliases: {
      B: 'bundler',
      b: 'bundle',
      q: 'quiet',
      W: 'public',
      D: 'dest',
      S: 'src',
      e: 'env',
      h: 'help',
      c: 'config',
      v: 'version',
      V: 'verbose',
      x: 'exclude',
      l: 'plugins',
      L: 'devPlugins',
      O: 'optimize',
      r: 'reloader',
      d: 'debug',
      f: 'force',
      w: 'watch',
      y: 'only',
      o: 'open',
      p: 'port',
      P: 'proxy',
      s: 'serve',
      R: 'rename',
      G: 'globals',
      E: 'extensions',
    },
  });
} catch (e) {
  errLog(`${e.message || e.toString()} (use --help for usage info)`);
  die(1);
}

// nice logs!
const _level = _.flags.verbose ? 'verbose' : _.flags.debug ? 'debug' : 'info';

logger = require('log-pose')
  .setLevel((_.flags.quiet && !_.flags.version && !_.flags.help) ? false : _level)
  .getLogger(12, process.stdout, process.stderr);

if (_.flags.debug && _.flags.verbose) {
  require('debug').enable('tarima,tarima:*,grown,grown:*,talavera:*');
  require('log-pose').setLevel(false);
}

// local debug
const debug = require('debug')('tarima');

const thisPkg = require(path.join(__dirname, '../package.json'));

_.flags.env = (_.flags.env !== true ? _.flags.env : '') || 'development';

// defaults
process.name = 'tarima';

process.env.NODE_ENV = _.flags.env;

logger.printf('{%green|%s v%s%} {%gray|(node %s)%}\n',
  thisPkg.name,
  thisPkg.version,
  process.version);

debug('v%s - node %s', thisPkg.version, process.version);

if (_.flags.version) {
  die();
}

const _bin = Object.keys(thisPkg.bin)[0];

if (_.flags.help) {
  logger.write(`
Usage:
  ${_bin} [OPTIONS]
  ${_bin} [...] js:es6 css:less
  ${_bin} [...] API_KEY=*secret* PORT=3000
  ${_bin} [...] "**/*:{basedir/1}/{fname}" "**/mock:{basedir/2}/api/{fname}"

Options:
  -S, --src         Sources files, comma separated (e.g. -S app -S public )
  -D, --dest        Destination directory (e.g. -D build/dist)
  -W, --public      Public directory for relative sources

  -e, --env         Customization per environment (e.g. -e production)

                    - NODE_ENV=development is required for watching
                    - Values are exported as globals depending on the environment:

                      "globals": {
                        "development": { ... },
                        "production": { ... },
                        "FOO": "bar"
                      }

  -w, --watch       Enable custom file watching (e.g. -w _src -w bin)
  -c, --config      Use configuration file (e.g. -c ./config.js)
                    You may also specify a suffix, e.g. -c DEV will map to ./tarima.DEV.{js,json}

  -l, --plugins     Shorthand option for loading plugins (e.g. -l tarima-bower -l talavera)
  -L, --devPlugins  Same as --plugins, development only (e.g. -L tarima-lr)
  -O, --optimize    Apply optimizations for final sources (google-closure-compiler-js, csso)

  -o, --open        Open browser (requires browser-sync/live-reload, see below)
  -p, --port        Enable custom port for serving files (e.g. tarima-lr)
  -P, --proxy       Enable proxying for local server (e.g. tarima-lr)
  -s, --serve       Enable file serving (e.g. with tarima-lr)

  -f, --force       Force rendering/bundling of all sources
  -b, --bundle      Scripts matching this will be bundled (e.g. -b "**/main/*.js")
  -B  --bundler     Choose bundler tool: webpack, rollup or fuse-box (e.g. -B webpack)

  -q, --quiet       Minimize output logs
  -d, --debug       Enable debug mode when transpiling
  -V, --verbose     Enable verbose logs (use for trouble-shooting)

  -y, --only        Filter out non-matching sources using src.indexOf("substr")
  -x, --exclude     Filter out sources using globs (e.g. -x test/broken -x .coffee)

                    Example patterns:
                      - *foo     -> !*foo
                      - .bar     -> !**/*.bar
                      - x.y      -> !**/x.y
                      - foo      -> !**/foo/**
                      - foo/bar  -> !**/foo/bar/**

  -r, --reloader    Load module for reset stuff on changes (e.g. -r bin/server)

                    Imported modules should be like:

                    module.exports = function start() {
                      return function stop() {};
                    };

  -E, --extensions  Enable hidden extensions (e.g. -E .es6.js -E .post.css -E .js.hbs.pug)
  -G, --globals     Shorthand for global variables (e.g. -G FOO=BAR -G AKI_PEY=xyz)
  -R, --rename      Custom naming expressions (e.g. -R "**/*:{basedir/1}/{fname}")

`);
  die(1);
}

const run = (opts, cb) => {
  const _runner = require('./lib');

  debug('settings %s', JSON.stringify(opts, null, 2));

  // delay once resolver loads
  process.nextTick(() => {
    try {
      _runner(opts, logger, cb);
    } catch (e) {
      errLog((_.flags.verbose && e.stack) || e.message || e.toString());
      die(1);
    }
  });
};

const spawn = require('child_process').spawn;

// empty dummy
let mainPkg = {};

const cwd = process.cwd();
const pkg = path.join(cwd, 'package.json');

// load .env
const env = require('dotenv').config({ silent: true }) || {};

if ($.isFile(pkg)) {
  debug('config %s', pkg);

  mainPkg = $.readJSON(pkg);
}

const defaultConfig = {
  cwd,
  src: $.toArray(_.flags.src),
  watch: $.toArray(_.flags.watch),
  bundle: $.toArray(_.flags.bundle),
  plugins: $.toArray(_.flags.plugins),
  devPlugins: $.toArray(_.flags.devPlugins),
  rename: _._.concat($.toArray(_.flags.rename)),
  dest: _.flags.dest || DEFAULTS.dest,
  public: _.flags.public || DEFAULTS.public,
  cacheFile: '.tarima',
  filter: [],
  notifications: {
    title: mainPkg.name || path.basename(cwd),
    okIcon: path.join(__dirname, 'ok.png'),
    errIcon: path.join(__dirname, 'err.png'),
  },
  bundleOptions: {
    bundler: _.flags.bundler,
    globals: _.data,
    optimize: _.flags.optimize,
    extensions: _.params,
  },
  flags: _.flags,
  reloader: _.flags.reloader,
};

// apply package settings
try {
  $.merge(defaultConfig, mainPkg.tarima || {});
} catch (e) {
  errLog(`Configuration mismatch: ${(_.flags.verbose && e.stack) || e.message || e.toString()}`);
  die(1);
}

// support for tarima.CONFIG.{js,json}
let configFile = _.flags.config === true ? 'config' : _.flags.config;

if (configFile && configFile.indexOf('.') === -1) {
  const fixedConfig = path.join(cwd, `tarima.${configFile}`);

  [`${fixedConfig}.js`, `${fixedConfig}.json`].forEach(file => {
    if ($.isFile(file)) {
      configFile = file;
    }
  });
}

if (configFile) {
  if (!$.isFile(configFile)) {
    logger.info('\r{%fail|Missing file: %s%}\n', configFile);
    die(1);
  }

  logger.info('{%log|Loading settings from %s%}\n', path.relative(cwd, configFile));

  debug('config %s', configFile);

  $.merge(defaultConfig, $.readJSON(path.resolve(configFile)));
}

// normalize extensions
$.merge(defaultConfig.bundleOptions.extensions, defaultConfig.extensions || {});

delete defaultConfig.extensions;

function fixedValue(string) {
  if (/^-?\d+(\.\d+)?$/.test(string)) {
    return parseFloat(string);
  }

  const values = {
    true: true,
    false: false,
  };

  if (typeof values[string] !== 'undefined') {
    return values[string];
  }

  return string || null;
}

if (_.flags.only) {
  const test = $.toArray(_.flags.only);

  debug('--only %s', test.join(' '));

  defaultConfig.filter.push(value => {
    value = path.relative(cwd, value);

    for (let i = 0; i < test.length; i += 1) {
      if (value.indexOf(test[i]) > -1) {
        return true;
      }
    }
  });
}

if (_.flags.exclude) {
  const test = $.toArray(_.flags.exclude);

  debug('--exclude %s', test.join(' '));

  test.forEach(skip => {
    if (skip.indexOf('*') > -1) {
      defaultConfig.filter.push(`!${skip}`);
    } else if (skip.substr(0, 1) === '.') {
      defaultConfig.filter.push(`!**/*${skip}`);
    } else if (skip.indexOf('.') > -1) {
      defaultConfig.filter.push(`!**/${skip}`);
    } else {
      defaultConfig.filter.push(`!**/${skip}/**`);
    }
  });
}

// apply globals first
const _globals = defaultConfig.globals || defaultConfig.env || {};

$.merge(env, _globals[_.flags.env] || {});
$.merge(env, _globals);

// package info
Object.defineProperty(env, 'env', {
  configurable: false,
  enumerable: false,
  get: () => $.extend({}, process.env),
});

Object.defineProperty(env, 'pkg', {
  configurable: false,
  enumerable: false,
  get: () => mainPkg,
});

Object.keys(env).forEach(key => {
  defaultConfig.bundleOptions.globals[key] = env[key];
});

if (_.flags.globals) {
  const test = $.toArray(_.flags.globals);

  debug('--globals %s', test.join(' '));

  test.forEach(value => {
    const parts = value.split('=');

    defaultConfig.bundleOptions.globals[parts[0]] = fixedValue(parts[1]);
  });
}

if (_.flags.extensions) {
  const test = $.toArray(_.flags.extensions);

  debug('--extensions %s', test.join(' '));

  test.forEach(exts => {
    const parts = exts.replace(/^\./, '').split('.').reverse();

    defaultConfig.bundleOptions.extensions[parts.shift()] = parts;
  });
}

defaultConfig.bundleOptions.compileDebug = _.flags.debug;
defaultConfig.bundleOptions.verboseDebug = _.flags.verbose;

const isDev = process.env.NODE_ENV === 'development';

const cmd = _.raw || [];

let child;

function end() {
  if (!(_.flags.server || isDev) || _.flags.reloader) {
    logger.write('\n');
  }
}

function infoFiles(result) {
  if (isDev && result.output.length) {
    $.notify(`${result.output.length} file${result.output.length !== 1 ? 's' : ''}`,
      defaultConfig.notifications.title,
      defaultConfig.notifications.okIcon);
  }

  if (!result.output.length) {
    logger.printf('\r\r{%ok|Without changes%}');
    end();
  }

  if (!isDev || result.output.length > 1) {
    logger.printf('\r\r{%end|%s file%s written%}',
        result.output.length,
        result.output.length !== 1 ? 's' : '');

    end();
  }
}

const _close = process.version.split('.')[1] === '6' ? 'exit' : 'close';

function exec(onError) {
  function restart() {
    // restart
    if (child) {
      child.kill('SIGINT');
    }

    const _cmd = cmd
      .map(arg => (arg.indexOf(' ') === -1 ? arg : `"${arg}"`)).join(' ');

    logger.printf('\r\r{%gray|$ %s%}\r\n', _cmd);

    debug('exec %s', _cmd);

    child = spawn(cmd[0], cmd.slice(1), {
      cwd: defaultConfig.cwd || defaultConfig.dest,
      detached: true,
    });

    child.stdout.pipe(process.stdout);

    const errors = [];

    child.stderr.on('data', data => {
      const line = data.toString().trim();

      if (line) {
        errors.push(line);
      }
    });

    child.on(_close, exitCode => {
      let message = `${_cmd}\n— `;
      let icon = defaultConfig.notifications.okIcon;

      if (exitCode || errors.length) {
        icon = defaultConfig.notifications.errIcon;
        message += 'Error';
      } else {
        message += 'Done';
      }

      $.notify(message, defaultConfig.notifications.title, icon);

      debug('exec %s - %s', exitCode, _cmd);

      if (errors.length) {
        errLog(errors.join('\n'));
        onError({ msg: errors.join('\n') });
      }

      if (exitCode && !isDev) {
        die(exitCode);
      }

      if (!isDev) {
        die();
      }
    });
  }

  return restart;
}

process.on('SIGINT', () => {
  logger.printf('\r\r');

  if (child) {
    child.kill('SIGINT');
  }

  die();
});

let _restart;

run(defaultConfig, function done(err, result) {
  debug('done %s file%s added - %s',
    result.output.length,
    result.output.length === 1 ? '' : 's',
    err || 'without errors');

  if (err) {
    logger.write('\n');

    errLog((_.flags.debug && err.stack) || err.message || err.toString());

    if (!(_.flags.server || isDev)) {
      die(1);
    }

    return;
  }

  infoFiles(result);

  if (!isDev && err) {
    if (child) {
      child.kill();
    }

    die(1);
  }

  if (cmd.length && !err) {
    _restart = _restart || exec(this.emit.bind(null, 'error'));
    _restart();
    return;
  }

  if (isDev) {
    if (result.output.length > 1) {
      logger.write('\n');
    }

    logger.printf('\r\r{%wait|Waiting for changes...%} {%gray|[press CTRL-C to quit]%}\r');

    end();
    return;
  }

  if (!_.flags.reloader) {
    die();
  }
});

if (defaultConfig.src.length > 1) {
  logger.info('{%log|Reading from:%}\n  %s\n',
    defaultConfig.src.map(src => `{%yellow|${src}/**%}`).join('\n  '));
} else {
  logger.info('{%log|Reading from:%} {%yellow|%s/**%}\n', defaultConfig.src[0]);
}

logger.info('{%log|Output to:%} {%yellow|%s%}\n', path.relative(cwd, defaultConfig.dest) || '.');
